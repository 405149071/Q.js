<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Q.js by miniflycn</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Q.js</h1>
        <h2>fake-MVVM library</h2>

        <section id="downloads">
          <a href="https://github.com/miniflycn/Q.js/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/miniflycn/Q.js/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/miniflycn/Q.js" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a id="qjs" class="anchor" href="#qjs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Q.js</h1>

<p><a href="https://travis-ci.org/miniflycn/Q.js"><img src="https://travis-ci.org/miniflycn/Q.js.svg?branch=master" alt="Build Status"></a></p>

<blockquote>
<p>模仿Vuejs的<code>伪MVVM</code>库，下面是使用说明</p>
</blockquote>

<h2>
<a id="一个简单例子" class="anchor" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>一个简单例子</h2>

<p>模版：</p>

<pre lang="template"><code>&lt;a id="demo" href="javascript:void(0)" q-text="msg"&gt;&lt;/a&gt;
</code></pre>

<p>脚本：</p>

<div class="highlight highlight-js"><pre><span class="pl-s">var</span> vm <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Q</span>({
    el<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>#demo<span class="pl-pds">'</span></span>,
    data<span class="pl-k">:</span> {
        msg<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>hello<span class="pl-pds">'</span></span>
    }
});</pre></div>

<p>则会展示：</p>

<pre><code>&lt;a href="javascript:void(0)"&gt;hello&lt;/a&gt;
</code></pre>

<p>当使用.$set()方法修改data时候会触发节点数据修改：</p>

<pre><code>vm.$set('msg', '你好');
</code></pre>

<p>则会展示：</p>

<pre><code>&lt;a href="javascript:void(0)"&gt;你好&lt;/a&gt;
</code></pre>

<h2>
<a id="基本概念" class="anchor" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本概念</h2>

<h2>
<a id="the-q-constructor" class="anchor" href="#the-q-constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Q Constructor</h2>

<blockquote>
<p>Q的构造函数是Q.js的核心。你能用它创建一个Q的实例：</p>
</blockquote>

<pre><code>var vm = new Q({ /* options */ });

</code></pre>

<h2>
<a id="options" class="anchor" href="#options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Options</h2>

<h3>
<a id="data" class="anchor" href="#data" aria-hidden="true"><span class="octicon octicon-link"></span></a>data</h3>

<ul>
<li>类型：<code>Object</code>
</li>
</ul>

<blockquote>
<p>用于初始化Q对象元数据：</p>
</blockquote>

<pre><code>var data = {
    msg: 'hello'
};
var vm = new Q({
    data: data
})
vm.$options.data === data // -&gt; true
</code></pre>

<blockquote>
<p>大部分操作都和对象与数组的操作相同，只有当设置值的时候需要使用<code>.$set</code>方法，因为我们没有defineProperty的支持。</p>
</blockquote>

<ul>
<li>得到data中msg的值：</li>
</ul>

<div class="highlight highlight-javascript"><pre>vm.msg <span class="pl-c">// -&gt; hello</span></pre></div>

<ul>
<li>设置msg的值</li>
</ul>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> obj <span class="pl-k">=</span> {
    msg<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>hello world!<span class="pl-pds">'</span></span>
};
vm.$set(<span class="pl-s1"><span class="pl-pds">'</span>msg<span class="pl-pds">'</span></span>, obj.msg); <span class="pl-c">// -&gt; hello world!</span></pre></div>

<ul>
<li>对于数组可使用大部分数组方法，目前已经支持了：<code>push</code>、<code>pop</code>、<code>unshift</code>、<code>shift</code>、<code>indexOf</code>、<code>splice</code>、<code>forEach</code>、<code>filter</code>
</li>
</ul>

<h3>
<a id="el" class="anchor" href="#el" aria-hidden="true"><span class="octicon octicon-link"></span></a>el</h3>

<ul>
<li>类型：<code>String | HTMLElement | Function</code>
</li>
</ul>

<p><code>//TODO</code></p>

<p>Provide the Q instance with an existing DOM element. It can be a CSS selector string, an actual HTMLElement, or a function that returns an HTMLElement. The resolved element will be accessible as <code>q.$el</code>.</p>

<h3>
<a id="directive" class="anchor" href="#directive" aria-hidden="true"><span class="octicon octicon-link"></span></a>directive</h3>

<ul>
<li>类型：Object</li>
</ul>

<p>告知<code>libaray</code>如何对节点进行操作，遵循Vuejs写法：</p>

<pre><code>&lt;element&gt;
  prefix-directiveId="[argument:] expression [| filters...]"&gt;
&lt;/element&gt;
</code></pre>

<p>简单例子：</p>

<pre><code>&lt;div id="myText" q-text="message"&gt;&lt;/div&gt;
</code></pre>

<p>Q.js中，默认的prefix是<code>q</code>，directiveId是<code>text</code>，expression是<code>message</code>。这个directive的作用是，当Q实例中<code>message</code>这一属性的值发生变化时，告知Q.js去更新这个节点的文本内容。这里表示<code>message</code>(key)对应的数据(value)，用<code>text</code>指令进行操作，<code>text</code>指令是在该节点塞入文字。例如：</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> myText <span class="pl-k">=</span> Q.get(<span class="pl-s1"><span class="pl-pds">'</span>#myText<span class="pl-pds">'</span></span>); <span class="pl-c">//Q.get():获取一个Q实例，遵循restful风格，如果不存在则创建一个，并把节点的dom信息</span></pre></div>

<h3>
<a id="自定义directive" class="anchor" href="#%E8%87%AA%E5%AE%9A%E4%B9%89directive" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义<code>directive</code>
</h3>

<p>举一个我们在todoMVC的例子：</p>

<pre><code>&lt;input q-todo-focus="editing" /&gt;
</code></pre>

<p>则表示<code>editing</code>对应的数据变化时执行<code>todo-focus</code>指令，看看我们<code>todo-focus</code>指令怎么写的：</p>

<pre><code>directives: {
    'todo-focus': function (value) {
        // 如果editing的值为false，则不处理
        if (!value) {
            return;
        }
        // 为true则，对该节点focus()一下
        var el = this.el;
        setTimeout(function () {
            el.focus();
        }, 0);
    }
}
</code></pre>

<h3>
<a id="通用directive" class="anchor" href="#%E9%80%9A%E7%94%A8directive" aria-hidden="true"><span class="octicon octicon-link"></span></a>通用<code>directive</code>
</h3>

<blockquote>
<p>目前只提供了极少的通用<code>directive</code>，未来可拓展</p>
</blockquote>

<ul>
<li>show - 显示与否</li>
</ul>

<pre><code>&lt;div q-show="isShow"&gt;show!&lt;div&gt;
</code></pre>

<p>Q实例的data中<code>isShow</code>的布尔值决定了这个节点是否显示</p>

<pre><code>data: {
    isShow: true;
}
</code></pre>

<ul>
<li>class - 是否添加class</li>
</ul>

<pre><code>&lt;div q-class="active: isActive"&gt;&lt;/div&gt;
</code></pre>

<pre><code>data: {
    isActive: true;
}
</code></pre>

<ul>
<li>value - 改变值</li>
</ul>

<p>用法与text类似，支持input等有value属性的标签</p>

<ul>
<li>text - 插入文本</li>
<li>repeat - 重复节点</li>
</ul>

<pre><code>&lt;li q-repeat="list"&gt;xxx&lt;/li&gt;
</code></pre>

<pre><code>data: {
    list: [];
}
</code></pre>

<ul>
<li>on - 事件绑定</li>
</ul>

<pre><code>&lt;div q-on="click: showMsg"&gt;&lt;/div&gt;
</code></pre>

<ul>
<li>model - 双向绑定（只支持input、textarea）</li>
<li>vm - 创建子VM(ViewModel,一个Q对象的实例)</li>
</ul>

<h3>
<a id="filter" class="anchor" href="#filter" aria-hidden="true"><span class="octicon octicon-link"></span></a>filter</h3>

<blockquote>
<p>如果设置了<code>filter</code>，则绑定的数据会经过<code>filter</code>才执行对应的<code>directive</code>，这是我们可以在塞入数据前做输出处理，或事件触发前做数据处理。</p>
</blockquote>

<p>模版：</p>

<pre><code>&lt;input id="demo" q-model="msg" q-on="keyup: showMsg | key enter" /&gt;
</code></pre>

<p><code>key</code>是其中一个通用filter，基本实现是：</p>

<pre><code>var keyCodes = {
        enter    : 13,
        tab      : 9,
        'delete' : 46, // delete是关键字，需要用引号包起来
        up       : 38,
        left     : 37,
        right    : 39,
        down     : 40,
        esc      : 27
    };

/**
 * A special filter that takes a handler function,
 * wraps it so it only gets triggered on specific
 * keypresses. v-on only.
 *
 * @param {String} key
 */
function key(handler, key) {
    if (!handler || key === undefined) return;
    var code = keyCodes[key];
    if (!code) {
        code = parseInt(key, 10);
    }
    return function (e) {
        if (e.keyCode === code) {
            return handler.call(this, e);
        }
    };
}
</code></pre>

<p>则，当keyup发生，keyCode为13(即enter)时候，才会触发showMsg方法。</p>

<h3>
<a id="method" class="anchor" href="#method" aria-hidden="true"><span class="octicon octicon-link"></span></a>method</h3>

<blockquote>
<p>特制<code>on</code>指令会调用的方法，例如：上面讲到的showMsg。</p>
</blockquote>

<p>设置方法：</p>

<pre><code>var vm = new Q({
    el: '#demo',
    filters: {
        key: key
    },
    data: {
        msg: 'hello'
    },
    methods: {
        showMsg: function () {
            alert(this.msg);
        }
    }
});
</code></pre>

<p>则那个input框会在初始化时自动设值为hello，当改变时候<code>msg</code>值也会改变，当按下<code>回车键</code>，则会触发showMsg方法打印值。</p>

<h2>
<a id="用户" class="anchor" href="#%E7%94%A8%E6%88%B7" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户</h2>

<p><img src="http://www.qxiu.com/2014/images/logo_qi.jpg" alt="齐齐互动视频"></p>
      </section>
    </div>

    
  </body>
</html>