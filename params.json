{"name":"Q.js","tagline":"fake-MVVM library","body":"Q.js\r\n====\r\n\r\n[![Build Status](https://travis-ci.org/miniflycn/Q.js.svg?branch=master)](https://travis-ci.org/miniflycn/Q.js)\r\n\r\n> 模仿Vuejs的`伪MVVM`库，下面是使用说明\r\n\r\n一个简单例子\r\n------------\r\n\r\n模版：\r\n```template\r\n<a id=\"demo\" href=\"javascript:void(0)\" q-text=\"msg\"></a>\r\n```\r\n\r\n脚本：\r\n```js\r\nvar vm = new Q({\r\n    el: '#demo',\r\n    data: {\r\n        msg: 'hello'\r\n    }\r\n});\r\n```\r\n\r\n则会展示：\r\n\r\n```\r\n<a href=\"javascript:void(0)\">hello</a>\r\n```\r\n\r\n当使用.$set()方法修改data时候会触发节点数据修改：\r\n\r\n```\r\nvm.$set('msg', '你好');\r\n```\r\n\r\n则会展示：\r\n\r\n```\r\n<a href=\"javascript:void(0)\">你好</a>\r\n```\r\n\r\n基本概念\r\n--------\r\n\r\n## The Q Constructor\r\n\r\n> Q的构造函数是Q.js的核心。你能用它创建一个Q的实例：\r\n\r\n```\r\nvar vm = new Q({ /* options */ });\r\n\r\n```\r\n\r\n## Options\r\n\r\n### data\r\n\r\n* 类型：`Object`\r\n\r\n> 用于初始化Q对象元数据：\r\n\r\n```\r\nvar data = {\r\n    msg: 'hello'\r\n};\r\nvar vm = new Q({\r\n    data: data\r\n})\r\nvm.$options.data === data // -> true\r\n```\r\n\r\n> 大部分操作都和对象与数组的操作相同，只有当设置值的时候需要使用`.$set`方法，因为我们没有defineProperty的支持。\r\n\r\n* 得到data中msg的值：\r\n\r\n```javascript\r\nvm.msg // -> hello\r\n```\r\n\r\n* 设置msg的值\r\n\r\n```javascript\r\nvar obj = {\r\n    msg: 'hello world!'\r\n};\r\nvm.$set('msg', obj.msg); // -> hello world!\r\n```\r\n\r\n* 对于数组可使用大部分数组方法，目前已经支持了：`push`、`pop`、`unshift`、`shift`、`indexOf`、`splice`、`forEach`、`filter`\r\n\r\n### el\r\n\r\n* 类型：`String | HTMLElement`\r\n\r\n通过一个给定的DOM元素生成一个Q实例。可以是一个CSS选择器字符串，一个实际存在的HTML元素，最终会在`q.$el`中。\r\n\r\n### directive\r\n\r\n* 类型：Object\r\n\r\n告知`libaray`如何对节点进行操作，遵循Vuejs写法：\r\n\r\n```\r\n<element>\r\n  prefix-directiveId=\"[argument:] expression [| filters...]\">\r\n</element>\r\n```\r\n\r\n简单例子：\r\n\r\n```\r\n<div id=\"myText\" q-text=\"message\"></div>\r\n```\r\n\r\nQ.js中，默认的prefix是`q`，directiveId是`text`，expression是`message`。这个directive的作用是，当Q实例中`message`这一属性的值发生变化时，告知Q.js去更新这个节点的文本内容。这里表示`message`(key)对应的数据(value)，用`text`指令进行操作，`text`指令是在该节点塞入文字。例如：\r\n```javascript\r\nvar myText = Q.get('#myText'); //Q.get():获取一个Q实例，遵循restful风格，如果不存在则创建一个，并把节点的dom信息\r\n```\r\n\r\n### 自定义`directive`\r\n\r\n举一个我们在todoMVC的例子：\r\n\r\n```\r\n<input q-todo-focus=\"editing\" />\r\n```\r\n\r\n则表示`editing`对应的数据变化时执行`todo-focus`指令，看看我们`todo-focus`指令怎么写的：\r\n\r\n```\r\ndirectives: {\r\n    'todo-focus': function (value) {\r\n        // 如果editing的值为false，则不处理\r\n        if (!value) {\r\n            return;\r\n        }\r\n        // 为true则，对该节点focus()一下\r\n        var el = this.el;\r\n        setTimeout(function () {\r\n            el.focus();\r\n        }, 0);\r\n    }\r\n}\r\n```\r\n\r\n### 通用`directive`\r\n\r\n> 目前只提供了极少的通用`directive`，未来可拓展\r\n\r\n* show - 显示与否\r\n\r\n```\r\n<div q-show=\"isShow\">show!<div>\r\n```\r\nQ实例的data中`isShow`的布尔值决定了这个节点是否显示\r\n```\r\ndata: {\r\n    isShow: true;\r\n}\r\n```\r\n\r\n* class - 是否添加class\r\n\r\n```\r\n<div q-class=\"active: isActive\"></div>\r\n```\r\n\r\n```\r\ndata: {\r\n    isActive: true;\r\n}\r\n```\r\n\r\n* value - 改变值\r\n\r\n用法与text类似，支持input等有value属性的标签\r\n\r\n* text - 插入文本\r\n* repeat - 重复节点\r\n\r\n```\r\n<li q-repeat=\"list\">xxx</li>\r\n```\r\n\r\n```\r\ndata: {\r\n    list: [];\r\n}\r\n```\r\n* on - 事件绑定\r\n\r\n```\r\n<div q-on=\"click: showMsg\"></div>\r\n```\r\n* model - 双向绑定（只支持input、textarea）\r\n* vm - 创建子VM(ViewModel,一个Q对象的实例)\r\n\r\n### filter\r\n\r\n> 如果设置了`filter`，则绑定的数据会经过`filter`才执行对应的`directive`，这是我们可以在塞入数据前做输出处理，或事件触发前做数据处理。\r\n\r\n模版：\r\n```\r\n<input id=\"demo\" q-model=\"msg\" q-on=\"keyup: showMsg | key enter\" />\r\n```\r\n\r\n`key`是其中一个通用filter，基本实现是：\r\n\r\n```\r\nvar keyCodes = {\r\n        enter    : 13,\r\n        tab      : 9,\r\n        'delete' : 46, // delete是关键字，需要用引号包起来\r\n        up       : 38,\r\n        left     : 37,\r\n        right    : 39,\r\n        down     : 40,\r\n        esc      : 27\r\n    };\r\n\r\n/**\r\n * A special filter that takes a handler function,\r\n * wraps it so it only gets triggered on specific\r\n * keypresses. v-on only.\r\n *\r\n * @param {String} key\r\n */\r\nfunction key(handler, key) {\r\n    if (!handler || key === undefined) return;\r\n    var code = keyCodes[key];\r\n    if (!code) {\r\n        code = parseInt(key, 10);\r\n    }\r\n    return function (e) {\r\n        if (e.keyCode === code) {\r\n            return handler.call(this, e);\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n则，当keyup发生，keyCode为13(即enter)时候，才会触发showMsg方法。\r\n\r\n### method\r\n\r\n> 特制`on`指令会调用的方法，例如：上面讲到的showMsg。\r\n\r\n设置方法：\r\n\r\n```\r\nvar vm = new Q({\r\n    el: '#demo',\r\n    filters: {\r\n        key: key\r\n    },\r\n    data: {\r\n        msg: 'hello'\r\n    },\r\n    methods: {\r\n        showMsg: function () {\r\n            alert(this.msg);\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n则那个input框会在初始化时自动设值为hello，当改变时候`msg`值也会改变，当按下`回车键`，则会触发showMsg方法打印值。\r\n\r\n用户\r\n----\r\n\r\n[![齐齐互动视频](http://www.qxiu.com/2014/images/logo_qi.jpg)](http://www.qxiu.com/)\r\n\r\n[![QQ群](http://qplus3.idqqimg.com/qun/portal/img/logo2.png)](http://qun.qq.com/)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}