{"name":"Q.js","tagline":"fake-MVVM library","body":"Q.js\r\n====\r\n\r\n> 模仿Vuejs的`伪MVVM`库，下面是使用说明\r\n\r\n一个简单例子\r\n------------\r\n\r\n模版：\r\n```template\r\n<a href=\"javascript:void(0)\" q-text=\"msg\"></a>\r\n```\r\n\r\n脚本：\r\n```js\r\nvar vm = new Q({\r\n    el: '#demo',\r\n    data: {\r\n        msg: 'hello'\r\n    }\r\n});\r\n```\r\n\r\n则会展示：\r\n\r\n```\r\n<a href=\"javascript:void(0)\">hello</a>\r\n```\r\n\r\n当使用.data方法修改data时候会触发节点数据修改：\r\n\r\n```\r\nvm.$set('msg', '你好');\r\n```\r\n\r\n则会展示：\r\n\r\n```\r\n<a href=\"javascript:void(0)\">你好</a>\r\n```\r\n\r\n基本概念\r\n--------\r\n\r\n### directive\r\n\r\n告知`libaray`如何对节点进行操作，遵循Vuejs写法：\r\n\r\n```\r\n<element\r\n  prefix-directiveId=\"[argument:] expression [| filters...]\">\r\n</element>\r\n```\r\n\r\n简单例子：\r\n\r\n```\r\n<div q-text=\"message\"></div>\r\n```\r\n\r\n这里表示`message`对应的数据，用`text`指令进行操作，`text`指令是在该节点塞入文字。\r\n\r\n### 自定义`directive`\r\n\r\n举一个我们在todoMVC的例子：\r\n\r\n```\r\n<input q-todo-focus=\"editing\" />\r\n```\r\n\r\n则表示`editing`对应的数据变化时执行`todo-focus`指令，看看我们`todo-focus`指令怎么写的：\r\n\r\n```\r\ndirectives: {\r\n    'todo-focus': function (value) {\r\n        // 如果editing的值为false，则不处理\r\n        if (!value) {\r\n            return;\r\n        }\r\n        // 为true则，对该节点focus()一下\r\n        var el = this.el;\r\n        setTimeout(function () {\r\n            el.focus();\r\n        }, 0);\r\n    }\r\n}\r\n```\r\n\r\n### 通用`directive`\r\n\r\n> 目前只提供了极少的通用`directive`，未来可拓展\r\n\r\n* show - 显示与否\r\n* class - 是否添加class\r\n* value - 改变值\r\n* text - 插入文本\r\n* repeat - 重复节点\r\n* on - 事件绑定\r\n* model - 双向绑定（只支持input、textarea）\r\n* vm - 创建子VM\r\n\r\n### filter\r\n\r\n> 如果设置了`filter`，则绑定的数据会经过`filter`才执行对应的`directive`，这是我们可以在塞入数据前做输出处理，或事件触发前做数据处理。\r\n\r\n模版：\r\n```\r\n<input q-model=\"msg\" q-on=\"keyup: showMsg | key enter\" />\r\n```\r\n\r\n`key`是其中一个通用filter，基本实现是：\r\n\r\n```\r\nvar keyCodes = {\r\n        enter    : 13,\r\n        tab      : 9,\r\n        'delete' : 46,\r\n        up       : 38,\r\n        left     : 37,\r\n        right    : 39,\r\n        down     : 40,\r\n        esc      : 27\r\n    };\r\n\r\n/**\r\n * A special filter that takes a handler function,\r\n * wraps it so it only gets triggered on specific\r\n * keypresses. v-on only.\r\n *\r\n * @param {String} key\r\n */\r\nfunction key(handler, key) {\r\n    if (!handler) return;\r\n    var code = keyCodes[key];\r\n    if (!code) {\r\n        code = parseInt(key, 10);\r\n    }\r\n    return function (e) {\r\n        if (e.keyCode === code) {\r\n            return handler.call(this, e);\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n则，当keyup发生，keyCode为13(即enter)时候，才会触发showMsg方法。\r\n\r\n### method\r\n\r\n> 特制`on`指令会调用的方法，例如：上面讲到的showMsg。\r\n\r\n设置方法：\r\n\r\n```\r\nvar vm = new Q({\r\n    el: '#demo',\r\n    data: {\r\n        msg: 'hello'\r\n    },\r\n    methods: {\r\n        showMsg: function () {\r\n            alert(this.msg);\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n则那个input框会在初始化时自动设值为hello，当改变时候`msg`值也会改变，当按下`回车键`，则会触发showMsg方法打印值。\r\n\r\n### data\r\n\r\n> 大部分操作都和对象与数组的操作相同，只有当设置值的时候需要使用`.$set`方法，因为我们没有defineProperty的支持。\r\n\r\n* 得到一个msg的值：\r\n\r\n```javascript\r\nvm.msg\r\n```\r\n\r\n* 设置msg的值\r\n\r\n```javascript\r\nvm.$set('msg', obj);\r\n```\r\n\r\n* 对于数组可使用大部分数组方法，目前已经支持了：`push`、`pop`、`unshift`、`shift`、`indexOf`、`splice`、`forEach`、`filter`\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}